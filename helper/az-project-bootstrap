#!/bin/bash -x

# This script bootstraps a Terraform project for Azure DevOps
# Running this script will create a remote tfstate file in a storage account.
# It also will create a Project oriented resource group and a service principle.
# The service principal has Owner for the resource group created and is 
# stored in a keyvault that can be accessed by Azure DevOps to configure the 
# Terraform scripts that are generated

set -o errexit  # exit if any statement returns a non-true return value
shopt -s expand_aliases

# Print out something but not the real thing
mask() {
  local n=3                    # number of chars to leave
  local a="${1:0:${#1}-n}"     # take all but the last n chars
  local b="${1:${#1}-n}"       # take the final n chars 
  printf "%s%s\n" "${a//?/*}" "$b"   # substitute a with asterisks
}

# geta and gets are functions for printing out Yaml in Bash less than v4
geta() {
  local _ref=$1
  local -a _lines
  local _i
  local _leading_whitespace
  local _len

  IFS=$'\n' read -rd '' -a _lines ||:
  _leading_whitespace=${_lines[0]%%[^[:space:]]*}
  _len=${#_leading_whitespace}
  for _i in "${!_lines[@]}"; do
    eval "$(printf '%s+=( "%s" )' "$_ref" "${_lines[$_i]:$_len}")"
  done
}

gets() {
  local _ref=$1
  local -a _result
  local IFS

  geta _result
  IFS=$'\n'
  printf -v "$_ref" '%s' "${_result[*]}"
}

echo "Check program requirements..."
(
  set +e
  programs=(az jq git)
  missing=0
  for i in ${programs[@]}; do
      command -v $i 2&> /dev/null
      if [ $? -eq 0 ]; then
          echo " * Found $i"
      else
          echo " * ERROR: missing $i"
          missing=1
      fi
  done
  if [[ "$missing" -ne 0 ]]; then
      echo "Missing required commands"
      exit 1
  fi
  set -e
)

usage() { 
  echo "`basename $0`"
  echo "   Usage: " 
  echo "     [-g <project resource group>] project resource group to create"
  echo "     [-u <service principal appid>] service principal appid"
  echo "     [-p <service principal password>] service principal password.  Required if using -a"
  echo "     [-e <environment>] environmental purpose.  Default is 'dev'"
  echo "     [-s <storage account>] storage account to use for Terraform state"
  echo "     [-c <container name>] storage account container to use for Terraform state"
  echo "     [-k <keyvault name>] keyvault to store service principal in"
  echo "     [-r <region>] region to use. EastUs or USGovVirginia are defaults"
  echo "     [-n <prefix>] prefix to use for Azure resources.  Must be unique across Azure"
  echo "     [-d <token>] Creates a DevOps project.  Requires a PAT Token with privileges to create projects in org"
  echo "     [-a <ADO project name>] ADO project to inject service principal and pipelines into"
  echo "     [-o <org>] URL of Azure DevOps organization."
  echo "     [-P] For Production.  This will be the envrionment used with the 'main' branch in Git.  Otherwise the branch will be env name."
  exit 1
}

# Catch any help requests
for arg in "$@"; do
  case "$arg" in
    --help| -h) 
        usage
        ;;
  esac
done


while getopts c:-:a:r:g:d:n:o:s:k:p:e:u:P option
do
  case "${option}"
  in
      a) ADO_PROJECT=${OPTARG};;
      g) RESOURCE_GROUP=${OPTARG};;
      n) PREFIX=${OPTARG};;
      u) SP_APPID=${OPTARG};;
      p) SP_PASSWORD=${OPTARG};;
      e) ENV_NAME=${OPTARG};;
      k) KEYVAULT_NAME=${OPTARG};;
      s) STORAGE_ACCT_NAME=${OPTARG};;
      c) CONTAINER_NAME=${OPTARG};;
      r) REGION=${OPTARG};;
      d) DEVOPS=${OPTARG};;
      o) ADO_ORG=${OPTARG};;
      P) PRODUCTION=true;;
      -) case "${OPTARG}" in
          terraform)
            TERRA_PROJECT=true
            ;;
          bicep)
            BICEP_PROJECT=true
            ;;
          *)
            usage
            ;;
        esac;;
      *) usage;;
      : ) usage;;
  esac
done
shift "$(($OPTIND -1))"

# If ENV_NAME is not passed in assume dev
if [ -z "$ENV_NAME" ]; then
  ENV_NAME="DEVELOP"
fi

ENV_SHORT=${ENV_NAME:0:4}
LENV_NAME=$(echo $ENV_NAME | tr "[:upper:]" "[:lower:]") 

if [ "$PRODUCTION" == "true" ]; then
  GIT_BRANCH="main"
fi

if [ -z $GIT_BRANCH ]; then
  GIT_BRANCH=$LENV_NAME
fi


# See if SP info was passed in or not
if ! [ -z $SP_APPID ]; then
  SP_INFO=$(az ad sp show --id $SP_APPID -o json)
  SP_NAME=$(echo $SP_INFO | jq -e -r 'select(.displayName != null) | .displayName')
  if [ -z $SP_PASSWORD ]; then
    echo "Password required when using -a"
    exit 1
  fi
fi

#Get a Random number that gets used for uniqueness
RND=$(echo $RANDOM | grep -o ....$)

# 4 digit random number if no prefix is defined
if [ -z $PREFIX ]; then
  PREFIX=PROJ-$RND
fi

# Get rid of weird characters because they cause issues in some Azure resources
PREFIX=$(echo $PREFIX | tr -dc '[:alnum:]\n\r')
UPREFIX=$(echo $PREFIX | tr "[:lower:]" "[:upper:]") 
LPREFIX=$(echo $PREFIX | tr "[:upper:]" "[:lower:]") 

if [ -z "$TERRA_PROJECT" ]; then
  TERRAFORM=false
else
  TERRAFORM=true
fi

if [ -z "$BICEP_PROJECT" ]; then
  BICEP=false
else
  BICEP=true
fi

if [[ $TERRAFORM == "true" && $BICEP == "true" ]]; then
  echo "ERROR cannot be both Terraform and Bicep"
  exit 1
fi

# Check if Region is passed in, otherwise eastus will be used
if [ -z "$REGION" ]; then
  # check if in gov or commercial
  CLOUD=`az account list-locations -o json | jq -r '.[0].name'`
  if [ ${CLOUD:0:5} = "usgov" ]; then
      REGION='usgovvirginia'
  else
      REGION='eastus'
  fi
fi

# Set RG name
if [ -z "$RESOURCE_GROUP" ]; then
  RESOURCE_GROUP=$UPREFIX-$ENV_SHORT-RG
fi

if [ $TERRAFORM == "true" ]; then
  # Set Terraform Storage Acct Name
  if [ -z "$STORAGE_ACCT_NAME" ]; then
    STORAGE_ACCT_NAME=tfst${LPREFIX}sa
    if [ ${#STORAGE_ACCT_NAME} -gt 24 ]; then
      echo "STORAGE_ACCT_NAME $STORAGE_ACCT_NAME is too long"
      exit 1
    fi
  fi

  # Set Container Name for Terraform state
  if [ -z "$CONTAINER_NAME" ]; then
    CONTAINER_NAME=tfst${LPREFIX}
    if [ ${#CONTAINER_NAME} -gt 24 ]; then
      echo "CONTAINER_NAME $CONTAINER_NAME is too long"
      exit 1
    fi
  fi
fi

# Set Keyvault where Service Principal info will be stored
if [ -z "$KEYVAULT_NAME" ]; then
  KEYVAULT_NAME=spinfo-$LPREFIX-kv
fi

# Set Service principal name to be used
if [ -z "$SP_NAME" ]; then
  SP_NAME=$LPREFIX-sp
fi


if [ -z "$DEVOPS" ]; then
  DEVOPS=$DEVOPS_PAT
  if [ -z "$DEVOPS" ]; then
    echo "ERROR: Must supply a PAT Token from Azure DevOps.  This can be"
    echo "done either on the command line with -d or via env with DEVOPS_PAT" 
    exit 1
  fi
  # Set default org
  if [ -z "$ADO_ORG" ]; then
    echo "ERROR: Must set ADO_ORG using -a or have ADO_ORG environment variable"
    exit 1
  fi
fi

if ! [ -z "$DEVOPS" ]; then
  IFS=$'\n'

  if [ $TERRAFORM == "true" ]; then
    # Only allow .tf and .tfvars files
    for z in $(find . -type f ! \( -name \*.tmpl -o -name \*.yml -o -name \*.tfvars -o -name \*.tf -o -path '*/\.*' \) -print -maxdepth 1 );do
      if test -f "$z"; then
        echo "Error: Directory must only contain .tf or .tfvar files."
        echo "       This script will bootstrap tf files and check them into Git"
        echo "       in an autogenerated ADO project with any other .tf files in the directory."
        exit 1
      fi
    done
  fi
  
  if [ $BICEP == "true" ]; then
    # Only allow .bicep and .json files
    for z in $(find . -type f ! \( -name \*.tmpl -o -name \*.yml -o -name \*.bicep -o -name \*.json -o -path '*/\.*' \) -print -maxdepth 1 );do
      if test -f "$z"; then
        echo "Error: Directory must only contain .bicep or .json files."
        echo "       This script will bootstrap bicep files and check them into Git"
        echo "       in an autogenerated ADO project with any other .bicep files in the directory."
        exit 1
      fi
    done
  fi

  unset IFS
fi

echo -e "\nThe following resources will be created...\n"

echo "RESOURCE_GROUP:       $RESOURCE_GROUP"
echo "PREFIX:               $PREFIX"
echo "ENV_NAME:             $ENV_NAME"
echo "ENV_SHORT:            $ENV_SHORT"
echo "SP_NAME:              $SP_NAME"
echo "KEYVAULT_NAME:        $KEYVAULT_NAME"
if [ $TERRAFORM == "true" ]; then
  echo "STORAGE_ACCT_NAME:    $STORAGE_ACCT_NAME"
  echo "CONTAINER_NAME:       $CONTAINER_NAME"
fi
echo "REGION:               $REGION"
echo "TERRAFORM PROJECT:    $TERRAFORM"
echo "BICEP PROJECT:        $BICEP"
echo "ADO_ORG:              $ADO_ORG"
echo "DEVOPS:               $DEVOPS"
echo "GIT_BRANCH:           $GIT_BRANCH"
echo ""
echo -e "NOTE: Service Principal $SP_NAME with Owner permissions on $RESOURCE_GROUP will be stored in $KEYVAULT_NAME\n"

read -p "Are you sure you want to Proceed [y/N]?"
if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
    echo "Maybe next time!"
    exit 1 
fi

if [ -d ".git" ]; then
  echo ""
  echo "WARNING: Directory already a git repo. There will be changes made to this Git repository! "
  read -p "Are you sure you want to Proceed [y/N]?"
  if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
      echo "Maybe next time!"
      exit 1 
  fi
fi

BRANCH_EXISTS=$(git -P branch --list "$LENV_NAME")
# If branch exists already probably should abort
if ! [ -z $BRANCH_EXISTS ]; then
  echo "ERROR: Git branch \"$ENV_NAME\" already exists.  Aborting."
  exit 1
fi

alias echo="echo -e"

# Create resource group or retrieve the existing id
RG_ID=$(az group create --name $RESOURCE_GROUP --location $REGION --query id -o tsv)

# Create storage account if required because of Terraform
if [ $TERRAFORM == "true" ]; then
  # Retrieve or create the storage account for Terraform state
  set +e
  SA_ID=$(az storage account show --name $STORAGE_ACCT_NAME --query "id" -o tsv)
  if [ $? -ne 0 ]; then
      echo "Storage Account does not exist.  Continuing and will create it".
      SA_ID=$(az storage account create --resource-group $RESOURCE_GROUP --name $STORAGE_ACCT_NAME --sku Standard_LRS --encryption-services blob --query "id" -o tsv)
  fi
  set -e


  # Get storage account key
  ACCOUNT_KEY=$(az storage account keys list --account-name $STORAGE_ACCT_NAME --query [0].value -o tsv)

  # Create blob container
  az storage container create --name $CONTAINER_NAME --account-name $STORAGE_ACCT_NAME --account-key $ACCOUNT_KEY 1>/dev/null

  echo "storage_account_name:   $STORAGE_ACCT_NAME"
  echo "container_name:         $CONTAINER_NAME"
fi

# Create Keyvault if it doesn't exist.  This keyvault will hold service principal info
# for our projects.  
set +e
KEYVAULT_ID=$(az keyvault show -n $KEYVAULT_NAME --query "id" -o tsv)
if [ $? -ne 0 ]; then
    echo "Keyvault does not exist.  Continuing and will create it".
    KEYVAULT_ID=$(az keyvault create -n $KEYVAULT_NAME -g $RESOURCE_GROUP --query "id" -o tsv)
fi
set -e

if [ -z $KEYVAULT_ID ]; then
  echo "ERROR: Cannot retrieve or create Keyvault. Exitting."
  exit 1
fi

#################################
#### Create Project Resources
#################################

# Create Service Principal
echo "Create or retrieve Service Principal"
if [ -z $SP_APPID ]; then
  echo "Looking up SP"
  SP_INFO=$(az ad sp create-for-rbac -n $SP_NAME --skip-assignment -o json)
  SP_PASSWORD=$(echo $SP_INFO | jq -e -r 'select(.password != null) | .password')
fi

# Grab info from the Service Principal
SP_APPID=$(echo $SP_INFO | jq -e -r 'select(.appId != null) | .appId')

# Reset SP_INFO so we are dealing with the same json whether it was passed in or not
SP_INFO=$(az ad sp show --id $SP_APPID)
SP_TENANTID=$(echo $SP_INFO | jq -e -r 'select(.appOwnerTenantId != null) | .appOwnerTenantId')
SP_OBJID=$(echo $SP_INFO | jq -e -r 'select(.objectId != null) | .objectId')
SUBSCRIPTION_ID=$(az account show --query id -o tsv)

#Now that we have a SP let's give it some permissions
az role assignment create --role Owner --scope $RG_ID --assignee $SP_APPID -o json

# echo "SP_APPID=$SP_APPID"
# echo "SP_PASSWORD=$SP_PASSWORD"
# echo "SP_TENANTID=$SP_TENANTID"
# echo "SUBSCRIPTION_ID=$SUBSCRIPTION_ID"

# Wait for Progagation via loop
echo "Sleeping in loop for 5 seconds to propagate SP"
until az ad sp show --id $SP_APPID &> /dev/null ; do echo "Waiting for Azure AD propagation" && sleep 5; done

# Add SP info and access key to keyvault
if [ $TERRAFORM == 'true' ]; then
  az keyvault secret set --vault-name $KEYVAULT_NAME --name "SA-ACCESS-KEY" --value "$ACCOUNT_KEY"
fi
az keyvault secret set --vault-name $KEYVAULT_NAME --name "SP-CLIENTID" --value "$SP_APPID"
az keyvault secret set --vault-name $KEYVAULT_NAME --name "SP-SUBSCRIPTIONID" --value "$SUBSCRIPTION_ID" 
az keyvault secret set --vault-name $KEYVAULT_NAME --name "SP-TENANTID" --value "$SP_TENANTID" 
az keyvault secret set --vault-name $KEYVAULT_NAME --name "SP-PASSWORD" --value "$SP_PASSWORD" 

# Allow SP to manage Keyvault
az keyvault set-policy --name $KEYVAULT_NAME --object-id $SP_OBJID \
  --certificate-permissions backup create delete deleteissuers get getissuers import list listissuers managecontacts manageissuers purge recover restore setissuers update \
  --key-permissions backup create decrypt delete encrypt get import list purge recover restore sign unwrapKey update verify wrapKey \
  --secret-permissions backup delete get list purge recover restore set \
  --storage-permissions backup delete deletesas get getsas list listsas purge recover regeneratekey restore set setsas update

# Get generic pipeline file done
gets GENERIC_PIPE <<'EOS'
trigger:
  branches:
    include:
    - $GIT_BRANCH
pool:
  vmImage: 'ubuntu-latest'
extends:
  template: azure-pipelines.tmpl
EOS

# Get generic pipeline part that is the same for either
gets GENERIC_PIPE_TMPL <<'EOS'
parameters:
- name: DESTROY
  displayName: 'Destroy infrastructure instead of create?'
  type: boolean
  default: false
steps:
#KEY VAULT TASK
- task: AzureKeyVault@1
  inputs:
    azureSubscription: 'AZURE-SP'
    KeyVaultName: '${KEYVAULT_NAME}'
    SecretsFilter: 'SP-CLIENTID,SP-SUBSCRIPTIONID,SP-TENANTID,SP-PASSWORD'
  displayName: 'Get key vault secrets as pipeline variables'

# AZ LOGIN
- script: |
    az login --service-principal -u "\$\(SP-CLIENTID\)" -p "\$\(SP-PASSWORD\)" --tenant "\$\(SP-TENANTID\)"
  displayName: 'Login the az cli'
EOS

# Generic pipeline that is created for either Bicep or Terraform
printf '%s\n' "$GENERIC_PIPE" > azure-pipelines-$GIT_BRANCH.yml
printf '%s\n' "$GENERIC_PIPE_TMPL" > azure-pipelines.tmpl

# Terraform only stuff
if [ $TERRAFORM == "true" ]; then
  # Get the latest release of azurerm provider
  AZURE_RM_LATEST=$(curl --silent "https://api.github.com/repositories/93446042/releases/latest" | 
    grep '"tag_name":' | 
    sed -E 's/.*"([^"]+)".*/\1/' | 
    sed -E 's/^v/~>/'
  )
  if [ -z $AZURE_RM_LATEST ]; then
    AZURE_RM_LATEST="2.50.0"
  fi

gets TERRA_PROVIDER <<'EOS'
terraform {
  required_providers {
    azurerm = {
      source  = \"hashicorp/azurerm\"
      version = \"$AZURE_RM_LATEST\"
    }
  }
  backend "azurerm" {
    storage_account_name  = \"$STORAGE_ACCT_NAME\"
    container_name        = \"$CONTAINER_NAME\"
    key                   = \"terraform.state.main\"
  }
}

provider "azurerm" {
  skip_provider_registration = true
  features {}
}
EOS

gets TERRA_TFVARS <<'EOS'
  # Added by bootstrap program
  prefix          = \"$PREFIX\"
EOS

gets TERRA_STARTER <<'EOS'
variable location {
  type        = string
  default     = \"eastus\"
}

variable prefix {
  type        = string
}

variable resource_group {
  type        = string
}

variable environment {
  type        = string
}

data \"azurerm_client_config\" \"current\" {} 
data \"azurerm_resource_group\" \"project-rg\" {
  name = var.resource_group 
}

locals { 
  # All variables used in this file should be 
  # added as locals here 
  resource_group          = data.azurerm_resource_group.project-rg.name
  prefix                  = lower(var.prefix)
  environment             = lower(var.environment)
  prefix_minus            = replace(local.prefix, \"-\", \"\")
  location                = var.location 
  common_tags = { 
    created_by = \"Terraform\" 
  }
}
resource "azurerm_key_vault" "vault" {
  name                  = \"\${local.prefix}-\${local.environment}-kv\"
  location              = local.location
  resource_group_name   = local.resource_group 
  sku_name              = \"standard\"
  tenant_id             = data.azurerm_client_config.current.tenant_id
  tags                  = local.common_tags 

  access_policy {
    tenant_id = data.azurerm_client_config.current.tenant_id
    object_id = data.azurerm_client_config.current.object_id

    key_permissions = [
      \"get\",\"list\",\"create\",\"delete\",\"encrypt\",\"decrypt\",\"unwrapKey\",\"wrapKey\",\"purge\",\"recover\",\"restore\"
    ]

    secret_permissions = [
      \"get\",\"list\",\"set\",\"delete\",\"purge\",\"recover\",\"restore\"
    ]
    certificate_permissions = [
      \"backup\",\"create\",\"delete\",\"get\",\"import\",\"list\",\"purge\",\"recover\",\"restore\",\"update\"
    ]
    storage_permissions = [
      \"get\",\"list\",\"set\",\"delete\",\"purge\",\"recover\",\"restore\"
    ]
  }
}
EOS

gets TERRA_PIPE_TMPL <<'EOS'
#KEY VAULT TASK BECAUSE SA Account KEY is needed by TF
- task: AzureKeyVault@1
  inputs:
    azureSubscription: 'AZURE-SP'
    KeyVaultName: '${KEYVAULT_NAME}'
    SecretsFilter: 'SA-ACCESS-KEY'
  displayName: 'Get SA-ACCESS-KEY as pipeline variables'
- script: |
    # Run Terraform
    set -x
    export ARM_CLIENT_ID=\$(SP-CLIENTID)
    export ARM_CLIENT_SECRET=\$(SP-PASSWORD)
    export ARM_SUBSCRIPTION_ID=\$(SP-SUBSCRIPTIONID)
    export ARM_TENANT_ID=\$(SP-TENANTID)
    export ARM_ACCESS_KEY=\$(SA-ACCESS-KEY)
    export TERRA_WORKSPACE=\$(ENVIRONMENT)
    echo '#######Terraform Init########'
    terraform init
    terraform workspace select \$TERRA_WORKSPACE || terraform workspace new \$TERRA_WORKSPACE
    echo '#######Terraform Plan########'
    terraform plan -out="out.plan" -var-file=terraform.tfvars -var=\"resource_group=\$(RESOURCE_GROUP)\" -var=\"environment=\$(ENVIRONMENT)\"
    echo '#######Terraform Apply########'
    terraform apply out.plan
  displayName: 'Terraform Init, Plan and Apply '
  condition: eq(\${{ parameters.DESTROY }}, false)

- script: |
    # Destroy with Terraform
    set -x
    export ARM_CLIENT_ID=\$(SP-CLIENTID)
    export ARM_CLIENT_SECRET=\$(SP-PASSWORD)
    export ARM_SUBSCRIPTION_ID=\$(SP-SUBSCRIPTIONID)
    export ARM_TENANT_ID=\$(SP-TENANTID)
    export ARM_ACCESS_KEY=\$(SA-ACCESS-KEY)
    export TERRA_WORKSPACE=\$(ENVIRONMENT)
    echo '#######Terraform Init########'
    terraform init
    terraform workspace select \$TERRA_WORKSPACE || terraform workspace new \$TERRA_WORKSPACE
    terraform destroy --auto-approve -var-file=terraform.tfvars -var=\"resource_group=\$(RESOURCE_GROUP)\" -var=\"environment=\$(ENVIRONMENT)\"
  displayName: 'Terraform Destroy '
  condition: \${{ parameters.DESTROY }}
EOS

  printf '%s\n' "$TERRA_STARTER" > bootstrap.tf 
  printf '%s\n' "$TERRA_PROVIDER" > provider.tf 
  printf '%s\n' "$TERRA_TFVARS" > terraform.tfvars
  printf '%s\n' "$TERRA_PIPE_TMPL" >> azure-pipelines.tmpl

fi


if [ $BICEP == "true" ]; then
  AZ_RESOURCE_API_VERSION=$(az provider show --namespace Microsoft.Resources --query "resourceTypes[?resourceType=='resourceGroups'].apiVersions | [0]" --out tsv | grep -v preview | head -n1)
  AZ_KEYVAULT_API_VERSION=$(az provider show --namespace Microsoft.KeyVault --query "resourceTypes[?resourceType=='vaults'].apiVersions | [0]" --out tsv | grep -v preview | head -n1)
  echo "AZ_RESOURCE_API_VERSION=$AZ_RESOURCE_API_VERSION"
  echo "AZ_KEYVAULT_API_VERSION=$AZ_KEYVAULT_API_VERSION"

gets BICEP_STARTER <<'EOS'
targetScope = 'subscription'

param resourceGroupName string

resource resource_group 'Microsoft.Resources/resourceGroups@$AZ_RESOURCE_API_VERSION' existing = {
  name: resourceGroupName 
}

module vault 'vault.bicep' = {
 name: 'vault-app'
 scope: resource_group
}
EOS

gets BICEP_KEYVAULT<<'EOS'
param location string = resourceGroup().location

var keyVaultName = uniqueString(resourceGroup().id)

resource keyVault 'Microsoft.KeyVault/vaults@$AZ_KEYVAULT_API_VERSION' = {
  name: keyVaultName
  location: location
  properties: {
    enabledForTemplateDeployment: true
    enableRbacAuthorization: false
    tenantId: subscription().tenantId
    sku: {
      family: 'A'
      name: 'standard'
    }  
    accessPolicies: [
      {
        objectId: '$SP_OBJID' 
        tenantId: '$SP_TENANTID'
        permissions: {
          keys : [
           'get'
           'list'
           'create'
           'delete'
           'encrypt'
           'decrypt'
           'unwrapKey'
           'wrapKey'
           'purge'
           'recover'
           'restore'
          ]
          secrets : [
           'get'
           'list'
           'set'
           'delete'
           'purge'
           'recover'
           'restore'
          ]
          certificates : [
            'backup'
            'create'
            'delete'
            'get'
            'import'
            'list'
            'purge'
            'recover'
            'restore'
            'update'
          ]
          storage : [
            'get'
            'list'
            'set'
            'delete'
            'purge'
            'recover'
            'restore'
          ]
        }
      }
    ]
  }
}

output keyVaultName string = keyVault.name
output keyVaultId string = keyVault.id
EOS

gets BICEP_PIPE_TMPL <<'EOS'
- script: |
    set -x
    az deployment create -f main.bicep --location \$(REGION) --parameters resourceGroupName=\$(RESOURCE_GROUP)
  displayName: 'Create Bicep Deploy'
  condition: eq(\${{ parameters.DESTROY }}, false)

- script: |
    # Destroy
    set -x
    az deployment create -f main.bicep --location \$(REGION) --parameters resourceGroupName=\$(RESOURCE_GROUP)
  displayName: 'Destroy Infra'
  condition: \${{ parameters.DESTROY }}
EOS
  
  printf '%s\n' "$BICEP_STARTER" > main.bicep
  printf '%s\n' "$BICEP_KEYVAULT" > vault.bicep
  printf '%s\n' "$BICEP_PIPE_TMPL" >> azure-pipelines.tmpl
fi

if ! [ -z $DEVOPS ]; then
  if [ -z $ADO_PROJECT ]; then
    ADO_PROJECT="terraform-$PREFIX"
  fi
  echo $DEVOPS | az devops login --organization $ADO_ORG
  set +e
  ADO_PROJECT_ID=$(az devops project show -p $ADO_PROJECT --query 'id' -o tsv)
  if [ $? -ne 0 ]; then
      echo "ADO Project does not exist.  Continuing and will create it".
      ADO_PROJECT_ID=$(az devops project create --name $ADO_PROJECT --org $ADO_ORG --query "id" -o tsv)
  fi
  set -e
  REPO=$(az repos show -r $ADO_PROJECT --project $ADO_PROJECT --query remoteUrl -o tsv)
  if [ $PRODUCTION == "true" ]; then
    REPO_ID=$(az repos show -r $ADO_PROJECT --project $ADO_PROJECT --query id -o tsv)
    az repos policy merge-strategy create \
      --blocking true \
      --branch $GIT_BRANCH \
      --enabled true \
      --repository-id $REPO_ID \
      --allow-no-fast-forward true \
      --org $ADO_ORG \
      --project $ADO_PROJECT 
  fi
  (
    set +e
    git init; git checkout -b $GIT_BRANCH; git add *; git commit -m 'initial commit'
    
    # Add any other stuff to the other branches too   
    for branch in $(git for-each-ref refs/heads | cut -d/ -f3- | grep -v $GIT_BRANCH); do
      git checkout $branch; git merge $GIT_BRANCH
    done

    # Add the origin but don't worry if the same one is already there
    git remote add origin $REPO
    set -e
  )
  git push -u origin --all
  #Setup service connection in project
  echo "Setting up SP in ADO Project"
  export AZURE_DEVOPS_EXT_AZURE_RM_SERVICE_PRINCIPAL_KEY="$SP_PASSWORD"

  # Get the existing SE in the ADO project named azure-sp if it exists otherwise create it
  SE_ID=$(az devops service-endpoint list -p $ADO_PROJECT --query "[?name=='azure-sp'].id" -o tsv)
  if [ -z $SE_ID ]; then
    SE_ID=$(az devops service-endpoint azurerm create \
      --name azure-sp \
      --azure-rm-tenant-id $SP_TENANTID  \
      --azure-rm-subscription-id $SUBSCRIPTION_ID \
      --azure-rm-subscription-name internal \
      --azure-rm-service-principal-id $SP_APPID \
      --project $ADO_PROJECT --query "id" -o tsv)
  fi
  echo "SE_ID=$SE_ID"

  sleep 15  

  # Allow pipelines to use this SP
  az devops service-endpoint update \
    --project $ADO_PROJECT \
    --id $SE_ID \
    --enable-for-all true

  # Let Azure work everything out related to the service connection
  sleep 15
  
  # Create and run the pipeline in ADO
  az pipelines create \
    --name "Terraform-Build-$GIT_BRANCH" \
    --description "Infra Build for $ENV_NAME" \
    --yml-path azure-pipelines-$GIT_BRANCH.yml \
    --branch $GIT_BRANCH \
    --project $ADO_PROJECT \
    --repository $REPO \
    --skip-first-run \
    --org $ADO_ORG

  sleep 5

  az pipelines variable create \
    --name RESOURCE_GROUP \
    --value $RESOURCE_GROUP \
    --project $ADO_PROJECT \
    --org $ADO_ORG \
    --pipeline-name Terraform-Build-$GIT_BRANCH \
    --allow-override false
  
  sleep 5

  az pipelines variable create \
    --name ENVIRONMENT \
    --value $ENV_SHORT \
    --project $ADO_PROJECT \
    --org $ADO_ORG \
    --pipeline-name Terraform-Build-$GIT_BRANCH \
    --allow-override false

  sleep 5 

  az pipelines variable create \
    --name REGION \
    --value $REGION \
    --project $ADO_PROJECT \
    --org $ADO_ORG \
    --pipeline-name Terraform-Build-$GIT_BRANCH \
    --allow-override false

  sleep 5

  az pipelines run \
    --name Terraform-Build-$GIT_BRANCH \
    --org $ADO_ORG \
    --project $ADO_PROJECT 

fi

echo "The $ENV_NAME environment has been created.  To create other environments and pipelines "
echo "in the same ADO project use the following command:"
echo ""
echo "az-project-bootstrap \\"
if [ $TERRAFORM == "true" ]; then
  echo " --terraform \\"
fi
if [ $BICEP == "true" ]; then
  echo "--bicep \\"
fi
echo "  -r $REGION \\"
echo "  -a $ADO_PROJECT \\"
echo "  -g <name of new environment resource group> \\"
echo "  -u $SP_APPID \\"
echo "  -p $SP_PASSWORD \\"
echo "  -o $ADO_ORG  \\"
echo "  -e <name of environment>  \\"
if [ $ $TERRAFORM ]; then
  echo "  -s $STORAGE_ACCT_NAME  \\"
  echo "  -c $CONTAINER_NAME \\"
fi
echo "  -k $KEYVAULT_NAME  \\"
echo "  -n $PREFIX"

echo "THE END"
